
1.Основные принципы ооп
    Абстракция
    Инкапсуляция
    полиморфизм
    наследования

    1.1
      Абстракция в объектно-ориентированном программировании -
      это процесс представления сущностей программы в упрощенной форме,
      скрывая лишние детали и концентрируясь только на основных характеристиках объекта.

    1.2
      Инкапсуляция в объектно-ориентированном программировании (ООП) относится к принципу,
      в соответствии с которым внутренние детали и реализация объекта (или класса) скрываются
      от внешнего мира, а взаимодействие с объектом происходит только через его общедоступные интерфейсы.

      Основная идея инкапсуляции заключается в том, что данные (поля) и методы (функции)
      класса объединены в одном объекте, и доступ к ним осуществляется через специально
      предназначенные интерфейсы (публичные методы). Это позволяет скрыть сложную внутреннюю
      реализацию объекта, обеспечивая только необходимые внешним объектам способы взаимодействия.

      Инкапсуляция помогает создавать более устойчивые и гибкие программы, поскольку изменения
      внутренней реализации объекта не влияют на внешние объекты, использующие этот объект
      через его интерфейс.

      Таким образом, ваше определение инкапсуляции - "принцип программирования, связанный с
      сокрытием реализации объектов классов в файлах или методах" - корректно описывает
      основную идею инкапсуляции, связанную со сокрытием деталей реализации объектов или
      классов от внешнего мира.

   1.3
    Полиморфизм это приставления одного объекта в разных видах.
    Полиморфизм в объектно-ориентированном программировании означает способность объекта
    вести себя по-разному в зависимости от контекста использования. Он может проявляться
    через наследование, интерфейсы или перегрузку методов. При этом объект одного класса
    может обладать различной функциональностью в зависимости от того, каким образом он
    используется.




-----------------------------------------------------------------------------------------------------------------------
  2. Контракты основных интерфейсов коллекций в Java

  В Java основные интерфейсы коллекций определены в java.util пакете.
  Они предоставляют общие методы для работы с коллекциями разного типа.
  Вот некоторые из основных интерфейсов:

   2.1
   List: Это упорядоченная коллекция, позволяющая дублированные элементы.
       Основные реализации: ArrayList, LinkedList, Vector.

    add(E element)
    get(int index)
    remove(int index)
    size()

   2.2
    Set: Это коллекция, не позволяющая дублированные элементы.
    Основные реализации: HashSet, TreeSet.

    add(E element)
    contains(Object o)
    remove(Object o)
    size()

   2.3
    Map: Представляет собой отображение ключ-значение. Основные реализации: HashMap, TreeMap, LinkedHashMap.

    put(K key, V value)
    get(Object key)
    remove(Object key)
    containsKey(Object key)

   2.4
   Queue: Представляет структуру данных в виде очереди. Основные реализации: LinkedList, PriorityQueue.

    offer(E e)
    poll()
    peek()

   2.5
   Deque: Представляет двустороннюю очередь, позволяющую добавлять и удалять элементы с обоих концов.
   Основные реализации: ArrayDeque, LinkedList.

    addFirst(E e)
    addLast(E e)
    removeFirst()
    removeLast()

   Эти интерфейсы определяют общие методы, которые должны быть реализованы конкретными классами,
   чтобы обеспечить работу с коллекциями. Использование правильного интерфейса в Java позволяет
   упростить взаимодействие с коллекциями и облегчить переход между различными реализациями.
--------------------------------------------------------------------------------------------------------------
  3. equals/hashcode

  3.1
   если для двух обетов equals возвращает true тогда HashCode - ы  должны быть ровны
  3.2
   если HashCode - ы двух обетов не ровны то equals должен возвращает false

---------------------------------------------------------------------------------------------------------------------------
4. immutable object
   Это тот объект у которого невозможно получить доступ измененного состояния извне.

   public class Point{
     int x;
     int y;
     private List<Aobject> list = new ArrayList<>();
   }

   final class Aobject{
       private int a;

       public int getA(){
         return this.a;
       }

       public void setA(int a){
            this.a=a;
       }

       public Aobject(int a){
            this.a=a;
       }
    }

  4.1
  надо в классе Point
  все поля сделать private final а лист в канструкторе или ,если есть geter то в нем сделать дип копи  листа ;
  дип копи ознояает что надо создать новый лист и в нем все обекти создовать с нуля new Aobject() и добовлять в лист
  и класс Point сделать final;
-----------------------------------------------------------------------------------------------------------------------
5 Basic Java Concurrency
5.1
Монитор это конструкция которых позволяет применять мьютекс





----------------------------------------------------------------------------------------------------------------
6
6.1
